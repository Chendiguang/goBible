## 复合数据类型
    复合数据类型由基本的数据类型以各种方式组合而成，参考原子和分子的关系。

# 数组


# slice
1. 创建一个数组的slice等于为数组创建一个别名
2. 为什么slice比较不可以直接使用==操作符做比较(slice只能允许和nil比较):
    （1）和数组元素不同, slice的元素是非直接的, 有可能slice可以包含它自身;
    （2）因为slice的元素不是直接的, 所以如果底层数组元素改变, 同一个slice在不同的时间会拥有不同的元素。
3. 值为nil的slice没有对应的底层数组。
    值为nil的slice的长度和容量均为0, 非nil的的slice的长度和容量也可能为0。
    如: []int{}, make([]int, 3)[3:]
4. 容量是数组的长度，为未来的

# 结构体
1. 比较
    如果结构体的所有成员变量都是可以比较的，那么这个结构体就是可比较的。
    可比较的结构体类型都可以作为map的键类型
2. 创建、初始化一个struct类型的变量并获取它的地址
    t := new(tree)
	t.value = value
    或(两种等价)
    t := &tree{value: value}
3. 结构体字面量
    没有快捷的方式来初始化结构体;
    必须遵循形状类型的定义;
4. 运用结构体嵌套和匿名函数可以减少代码量和提高维护性
    


  <!-- 重要 -->
  make([]T, len) 
  make([]T, len, cap) // 相当于make([]T, cap)[:len]
  原理:
    make创建了一个无名数组并返回了它的一个slice, 这个数组仅可以通过这个slice来访问。
  <!--  -->


###### 注意点 ####
1. 字符串子串操作和对字节slice([]byte)做slice操作
（1）相似性
    都写作x[m:n], 并且都返回原始字节的一个子序列, 
    底层引用方式相同, 操作消耗常量时间
（2）差异
    返回值的类型不一样

2. slice的引用
    如果引用超过了被引用对象的容量(即cap(s)), 那么导致宕机;
    如果引用超出了被引用对象的长度(即len(s)), 最终的slice比原slice长(扩展)。

3. 对于引用类型, 例如指针和通道, 操作符==检查的是引用相等性, 即是否指向相等的元素。

4. 底层数组的元素是间接引用的, 但是slice的指针、长度和容量都不是。
